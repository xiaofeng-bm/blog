---
title: 复杂度分析
date: 2020-03-20
---
个人感觉，复杂度分析的作用就是
学习算法和数据结构就是为了让代码运行效率高，说白了，就是运行块，消耗内存少。  
但是具体怎么来评估呢，就引入了`时间复杂度`和`空间复杂度`两个概念。  

## 为什么需要分析复杂度
一开始我也觉得，拿一段代码，直接上机器跑一下，找找工具分析一下，看一下用了多长时间，消耗了多少内存，这样多直观。  

但是会发现，不同的电脑，不用的使用环境，不同的数据量等，对最后的结果影响很大。  

此时，就需要一种方法，或者说一个公式来帮我们粗略的估算一下执行效率。

学习`时间复杂度`和`空间复杂度`分析的作用就是，让你在写完某个算法的时候，内心就自然而然的对这个算法的执行效率有个大概的认知，比如你写了两个算法。一个需要两层for循环，一个只需要一层for循环，此时你心里立马就知道，两次for循环的肯定比一层for循环的效率低。

 ## 时间复杂度（大O）
先看下面一段代码：
```js
function cal(n) {
  let sum = 0;                    // 1 * unit_time
  for (let i = 0; i <= n; i++) {  // n * unit_time
    sum += i                      // n * unit_time
  }
  return sum;                     // 1* unit_time
}
```
假设执行一行代码的时间为unit_time，那上面的代码就需要(1 + n + n + 1) * unit_time = (2 + 2n) * unit_time。

下面在看一个复杂一点的：
```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {                  // n * unit_time
    for (let j = 0; j < arr.length -i -1; j++) {          // n * n * unit_time
      if(arr[i] > arr[j + 1]) {                           // n * n * unit_time
        let tem = arr[j];                                 // n * n * unit_time
        arr[j] = arr[j + 1];                              // n * n * unit_time
        arr[j + 1] = tem;                                 // n * n * unit_time
      }
    }
  }
  return arr                                              // 1 * unit_time
}
```
分析上面代码总执行时间就需要（5n² + n + 1）* unit_time的时间，所以T(n) = (5n² + n + 1）* unit_time。  
可以看出，n和T成正比，n的大小对整体的时间影响是非常大的，n越大，总耗时就越多。总结成一个公式就是：  
```
T(n) = O(f(n));
f(n) = (5n² + n + 1）* unit_time
```
当n非常大的时候，公式中的5，n，1对结果的影响就较小了，可以忽略掉。   

**总结就是：分析一个算法的时间复杂度的时候，我们只需要关注执行次数做多的那一段代码。**    

那上面的排序算法时间复杂度就可以简化为
```
T(n) = O(n²)
```

### 总结
大部分情况下。影响复杂度的就是for， while循环等。嵌套越多的循环复杂度越高，而且所消耗的时间也是呈指数级增长。所以说正常的代码中，for循环嵌套最好不要超过两层，如果达到4层或者4层以上，这个算法消耗的时间就会非常糟糕，如果你的算法复杂度超过了O(n²)，你就要考虑考虑优化了。