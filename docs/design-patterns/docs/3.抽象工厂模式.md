---
title: 3.抽象工厂模式
date: 2020-06-29
---
上一节介绍了简单工厂模式，拿生产手机来举例。但是上一节的我们的代码存在一个很严重的问题，违反了我们一开始说的设计模式中的**开放封闭原则**

具体是哪违反了呢，上一节我们的`getPhone`可以生产`iphone11`和`mate30`，但是现实中一个手机工厂肯定不是只生产这两种型号的手机的，而且生产的手机也是每年在变的，比如今年生产`mate30`，明年可能就转向生产`mate40`了。

如果要在代码中实现上面的逻辑的话，你会怎么做，肯定会想，那我新加一个型号的手机，我在`switch`中在加一个`case`不就行了吗，比如要加一个小米10，代码如下：
```js
function getPhone(name) {
  let params = [];
  switch (name) {
    case "iphone11":
      params = ["A13", "索尼", "康宁",, "ios"];
      break;
    case "mate30":
      params = ["麒麟990", "莱卡", "康宁", "安卓"];
      break;
    // 添加小米10
    case "小米10":
      params = ["骁龙865", "索尼", "康宁", "安卓"];
      break;
    default:
      params = [];
      break;
  }
  return new Phone(...params);
}
```
上面只有3中手机，现实中可能有几十种，加上更新换代的手机，可能有几百种型号，如果每次有改动都去修改`getPhone`函数的话，当手机型号有几百种，这个`switch`变得巨大无比的时候，试问公司人谁敢去动这个函数，一旦不小心把哪里改错了，一个大锅就背你身上了。而且像我们上面所说，违反了设计模式中的**开放封闭原则**

**开放封闭原则**就是：对扩展开放，对修改封闭。拿上面那个`getPhone`来举例，这是一个公共的函数，我们可以对它进行扩展，但是不要对它进行修改。那说半天，具体咋扩展呢，就引入了下面的**抽象工厂模式**
